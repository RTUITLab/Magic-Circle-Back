// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/0B1t322/Magic-Circle/ent/migrate"

	"github.com/0B1t322/Magic-Circle/ent/adjacenttable"
	"github.com/0B1t322/Magic-Circle/ent/admin"
	"github.com/0B1t322/Magic-Circle/ent/direction"
	"github.com/0B1t322/Magic-Circle/ent/institute"
	"github.com/0B1t322/Magic-Circle/ent/profile"
	"github.com/0B1t322/Magic-Circle/ent/sector"
	"github.com/0B1t322/Magic-Circle/ent/superadmin"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AdjacentTable is the client for interacting with the AdjacentTable builders.
	AdjacentTable *AdjacentTableClient
	// Admin is the client for interacting with the Admin builders.
	Admin *AdminClient
	// Direction is the client for interacting with the Direction builders.
	Direction *DirectionClient
	// Institute is the client for interacting with the Institute builders.
	Institute *InstituteClient
	// Profile is the client for interacting with the Profile builders.
	Profile *ProfileClient
	// Sector is the client for interacting with the Sector builders.
	Sector *SectorClient
	// SuperAdmin is the client for interacting with the SuperAdmin builders.
	SuperAdmin *SuperAdminClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AdjacentTable = NewAdjacentTableClient(c.config)
	c.Admin = NewAdminClient(c.config)
	c.Direction = NewDirectionClient(c.config)
	c.Institute = NewInstituteClient(c.config)
	c.Profile = NewProfileClient(c.config)
	c.Sector = NewSectorClient(c.config)
	c.SuperAdmin = NewSuperAdminClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		AdjacentTable: NewAdjacentTableClient(cfg),
		Admin:         NewAdminClient(cfg),
		Direction:     NewDirectionClient(cfg),
		Institute:     NewInstituteClient(cfg),
		Profile:       NewProfileClient(cfg),
		Sector:        NewSectorClient(cfg),
		SuperAdmin:    NewSuperAdminClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:        cfg,
		AdjacentTable: NewAdjacentTableClient(cfg),
		Admin:         NewAdminClient(cfg),
		Direction:     NewDirectionClient(cfg),
		Institute:     NewInstituteClient(cfg),
		Profile:       NewProfileClient(cfg),
		Sector:        NewSectorClient(cfg),
		SuperAdmin:    NewSuperAdminClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AdjacentTable.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.AdjacentTable.Use(hooks...)
	c.Admin.Use(hooks...)
	c.Direction.Use(hooks...)
	c.Institute.Use(hooks...)
	c.Profile.Use(hooks...)
	c.Sector.Use(hooks...)
	c.SuperAdmin.Use(hooks...)
}

// AdjacentTableClient is a client for the AdjacentTable schema.
type AdjacentTableClient struct {
	config
}

// NewAdjacentTableClient returns a client for the AdjacentTable from the given config.
func NewAdjacentTableClient(c config) *AdjacentTableClient {
	return &AdjacentTableClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adjacenttable.Hooks(f(g(h())))`.
func (c *AdjacentTableClient) Use(hooks ...Hook) {
	c.hooks.AdjacentTable = append(c.hooks.AdjacentTable, hooks...)
}

// Create returns a create builder for AdjacentTable.
func (c *AdjacentTableClient) Create() *AdjacentTableCreate {
	mutation := newAdjacentTableMutation(c.config, OpCreate)
	return &AdjacentTableCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AdjacentTable entities.
func (c *AdjacentTableClient) CreateBulk(builders ...*AdjacentTableCreate) *AdjacentTableCreateBulk {
	return &AdjacentTableCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AdjacentTable.
func (c *AdjacentTableClient) Update() *AdjacentTableUpdate {
	mutation := newAdjacentTableMutation(c.config, OpUpdate)
	return &AdjacentTableUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdjacentTableClient) UpdateOne(at *AdjacentTable) *AdjacentTableUpdateOne {
	mutation := newAdjacentTableMutation(c.config, OpUpdateOne, withAdjacentTable(at))
	return &AdjacentTableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdjacentTableClient) UpdateOneID(id int) *AdjacentTableUpdateOne {
	mutation := newAdjacentTableMutation(c.config, OpUpdateOne, withAdjacentTableID(id))
	return &AdjacentTableUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AdjacentTable.
func (c *AdjacentTableClient) Delete() *AdjacentTableDelete {
	mutation := newAdjacentTableMutation(c.config, OpDelete)
	return &AdjacentTableDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AdjacentTableClient) DeleteOne(at *AdjacentTable) *AdjacentTableDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AdjacentTableClient) DeleteOneID(id int) *AdjacentTableDeleteOne {
	builder := c.Delete().Where(adjacenttable.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdjacentTableDeleteOne{builder}
}

// Query returns a query builder for AdjacentTable.
func (c *AdjacentTableClient) Query() *AdjacentTableQuery {
	return &AdjacentTableQuery{
		config: c.config,
	}
}

// Get returns a AdjacentTable entity by its id.
func (c *AdjacentTableClient) Get(ctx context.Context, id int) (*AdjacentTable, error) {
	return c.Query().Where(adjacenttable.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdjacentTableClient) GetX(ctx context.Context, id int) *AdjacentTable {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the Profile edge of a AdjacentTable.
func (c *AdjacentTableClient) QueryProfile(at *AdjacentTable) *ProfileQuery {
	query := &ProfileQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adjacenttable.Table, adjacenttable.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, adjacenttable.ProfileTable, adjacenttable.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySector queries the Sector edge of a AdjacentTable.
func (c *AdjacentTableClient) QuerySector(at *AdjacentTable) *SectorQuery {
	query := &SectorQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adjacenttable.Table, adjacenttable.FieldID, id),
			sqlgraph.To(sector.Table, sector.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, adjacenttable.SectorTable, adjacenttable.SectorColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AdjacentTableClient) Hooks() []Hook {
	return c.hooks.AdjacentTable
}

// AdminClient is a client for the Admin schema.
type AdminClient struct {
	config
}

// NewAdminClient returns a client for the Admin from the given config.
func NewAdminClient(c config) *AdminClient {
	return &AdminClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `admin.Hooks(f(g(h())))`.
func (c *AdminClient) Use(hooks ...Hook) {
	c.hooks.Admin = append(c.hooks.Admin, hooks...)
}

// Create returns a create builder for Admin.
func (c *AdminClient) Create() *AdminCreate {
	mutation := newAdminMutation(c.config, OpCreate)
	return &AdminCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Admin entities.
func (c *AdminClient) CreateBulk(builders ...*AdminCreate) *AdminCreateBulk {
	return &AdminCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Admin.
func (c *AdminClient) Update() *AdminUpdate {
	mutation := newAdminMutation(c.config, OpUpdate)
	return &AdminUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdminClient) UpdateOne(a *Admin) *AdminUpdateOne {
	mutation := newAdminMutation(c.config, OpUpdateOne, withAdmin(a))
	return &AdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdminClient) UpdateOneID(id int) *AdminUpdateOne {
	mutation := newAdminMutation(c.config, OpUpdateOne, withAdminID(id))
	return &AdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Admin.
func (c *AdminClient) Delete() *AdminDelete {
	mutation := newAdminMutation(c.config, OpDelete)
	return &AdminDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AdminClient) DeleteOne(a *Admin) *AdminDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AdminClient) DeleteOneID(id int) *AdminDeleteOne {
	builder := c.Delete().Where(admin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdminDeleteOne{builder}
}

// Query returns a query builder for Admin.
func (c *AdminClient) Query() *AdminQuery {
	return &AdminQuery{
		config: c.config,
	}
}

// Get returns a Admin entity by its id.
func (c *AdminClient) Get(ctx context.Context, id int) (*Admin, error) {
	return c.Query().Where(admin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdminClient) GetX(ctx context.Context, id int) *Admin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstitute queries the Institute edge of a Admin.
func (c *AdminClient) QueryInstitute(a *Admin) *InstituteQuery {
	query := &InstituteQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(admin.Table, admin.FieldID, id),
			sqlgraph.To(institute.Table, institute.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, admin.InstituteTable, admin.InstituteColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AdminClient) Hooks() []Hook {
	return c.hooks.Admin
}

// DirectionClient is a client for the Direction schema.
type DirectionClient struct {
	config
}

// NewDirectionClient returns a client for the Direction from the given config.
func NewDirectionClient(c config) *DirectionClient {
	return &DirectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `direction.Hooks(f(g(h())))`.
func (c *DirectionClient) Use(hooks ...Hook) {
	c.hooks.Direction = append(c.hooks.Direction, hooks...)
}

// Create returns a create builder for Direction.
func (c *DirectionClient) Create() *DirectionCreate {
	mutation := newDirectionMutation(c.config, OpCreate)
	return &DirectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Direction entities.
func (c *DirectionClient) CreateBulk(builders ...*DirectionCreate) *DirectionCreateBulk {
	return &DirectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Direction.
func (c *DirectionClient) Update() *DirectionUpdate {
	mutation := newDirectionMutation(c.config, OpUpdate)
	return &DirectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DirectionClient) UpdateOne(d *Direction) *DirectionUpdateOne {
	mutation := newDirectionMutation(c.config, OpUpdateOne, withDirection(d))
	return &DirectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DirectionClient) UpdateOneID(id int) *DirectionUpdateOne {
	mutation := newDirectionMutation(c.config, OpUpdateOne, withDirectionID(id))
	return &DirectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Direction.
func (c *DirectionClient) Delete() *DirectionDelete {
	mutation := newDirectionMutation(c.config, OpDelete)
	return &DirectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DirectionClient) DeleteOne(d *Direction) *DirectionDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DirectionClient) DeleteOneID(id int) *DirectionDeleteOne {
	builder := c.Delete().Where(direction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DirectionDeleteOne{builder}
}

// Query returns a query builder for Direction.
func (c *DirectionClient) Query() *DirectionQuery {
	return &DirectionQuery{
		config: c.config,
	}
}

// Get returns a Direction entity by its id.
func (c *DirectionClient) Get(ctx context.Context, id int) (*Direction, error) {
	return c.Query().Where(direction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DirectionClient) GetX(ctx context.Context, id int) *Direction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstitute queries the Institute edge of a Direction.
func (c *DirectionClient) QueryInstitute(d *Direction) *InstituteQuery {
	query := &InstituteQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(direction.Table, direction.FieldID, id),
			sqlgraph.To(institute.Table, institute.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, direction.InstituteTable, direction.InstituteColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfile queries the Profile edge of a Direction.
func (c *DirectionClient) QueryProfile(d *Direction) *ProfileQuery {
	query := &ProfileQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(direction.Table, direction.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, direction.ProfileTable, direction.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DirectionClient) Hooks() []Hook {
	return c.hooks.Direction
}

// InstituteClient is a client for the Institute schema.
type InstituteClient struct {
	config
}

// NewInstituteClient returns a client for the Institute from the given config.
func NewInstituteClient(c config) *InstituteClient {
	return &InstituteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `institute.Hooks(f(g(h())))`.
func (c *InstituteClient) Use(hooks ...Hook) {
	c.hooks.Institute = append(c.hooks.Institute, hooks...)
}

// Create returns a create builder for Institute.
func (c *InstituteClient) Create() *InstituteCreate {
	mutation := newInstituteMutation(c.config, OpCreate)
	return &InstituteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Institute entities.
func (c *InstituteClient) CreateBulk(builders ...*InstituteCreate) *InstituteCreateBulk {
	return &InstituteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Institute.
func (c *InstituteClient) Update() *InstituteUpdate {
	mutation := newInstituteMutation(c.config, OpUpdate)
	return &InstituteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InstituteClient) UpdateOne(i *Institute) *InstituteUpdateOne {
	mutation := newInstituteMutation(c.config, OpUpdateOne, withInstitute(i))
	return &InstituteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InstituteClient) UpdateOneID(id int) *InstituteUpdateOne {
	mutation := newInstituteMutation(c.config, OpUpdateOne, withInstituteID(id))
	return &InstituteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Institute.
func (c *InstituteClient) Delete() *InstituteDelete {
	mutation := newInstituteMutation(c.config, OpDelete)
	return &InstituteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InstituteClient) DeleteOne(i *Institute) *InstituteDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InstituteClient) DeleteOneID(id int) *InstituteDeleteOne {
	builder := c.Delete().Where(institute.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InstituteDeleteOne{builder}
}

// Query returns a query builder for Institute.
func (c *InstituteClient) Query() *InstituteQuery {
	return &InstituteQuery{
		config: c.config,
	}
}

// Get returns a Institute entity by its id.
func (c *InstituteClient) Get(ctx context.Context, id int) (*Institute, error) {
	return c.Query().Where(institute.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InstituteClient) GetX(ctx context.Context, id int) *Institute {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDirections queries the Directions edge of a Institute.
func (c *InstituteClient) QueryDirections(i *Institute) *DirectionQuery {
	query := &DirectionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(institute.Table, institute.FieldID, id),
			sqlgraph.To(direction.Table, direction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, institute.DirectionsTable, institute.DirectionsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdmins queries the Admins edge of a Institute.
func (c *InstituteClient) QueryAdmins(i *Institute) *AdminQuery {
	query := &AdminQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(institute.Table, institute.FieldID, id),
			sqlgraph.To(admin.Table, admin.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, institute.AdminsTable, institute.AdminsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InstituteClient) Hooks() []Hook {
	return c.hooks.Institute
}

// ProfileClient is a client for the Profile schema.
type ProfileClient struct {
	config
}

// NewProfileClient returns a client for the Profile from the given config.
func NewProfileClient(c config) *ProfileClient {
	return &ProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profile.Hooks(f(g(h())))`.
func (c *ProfileClient) Use(hooks ...Hook) {
	c.hooks.Profile = append(c.hooks.Profile, hooks...)
}

// Create returns a create builder for Profile.
func (c *ProfileClient) Create() *ProfileCreate {
	mutation := newProfileMutation(c.config, OpCreate)
	return &ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Profile entities.
func (c *ProfileClient) CreateBulk(builders ...*ProfileCreate) *ProfileCreateBulk {
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Profile.
func (c *ProfileClient) Update() *ProfileUpdate {
	mutation := newProfileMutation(c.config, OpUpdate)
	return &ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfileClient) UpdateOne(pr *Profile) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfile(pr))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfileClient) UpdateOneID(id int) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfileID(id))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Profile.
func (c *ProfileClient) Delete() *ProfileDelete {
	mutation := newProfileMutation(c.config, OpDelete)
	return &ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProfileClient) DeleteOne(pr *Profile) *ProfileDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProfileClient) DeleteOneID(id int) *ProfileDeleteOne {
	builder := c.Delete().Where(profile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfileDeleteOne{builder}
}

// Query returns a query builder for Profile.
func (c *ProfileClient) Query() *ProfileQuery {
	return &ProfileQuery{
		config: c.config,
	}
}

// Get returns a Profile entity by its id.
func (c *ProfileClient) Get(ctx context.Context, id int) (*Profile, error) {
	return c.Query().Where(profile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfileClient) GetX(ctx context.Context, id int) *Profile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDirection queries the Direction edge of a Profile.
func (c *ProfileClient) QueryDirection(pr *Profile) *DirectionQuery {
	query := &DirectionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(direction.Table, direction.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, profile.DirectionTable, profile.DirectionColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdjacentTables queries the AdjacentTables edge of a Profile.
func (c *ProfileClient) QueryAdjacentTables(pr *Profile) *AdjacentTableQuery {
	query := &AdjacentTableQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(adjacenttable.Table, adjacenttable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.AdjacentTablesTable, profile.AdjacentTablesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfileClient) Hooks() []Hook {
	return c.hooks.Profile
}

// SectorClient is a client for the Sector schema.
type SectorClient struct {
	config
}

// NewSectorClient returns a client for the Sector from the given config.
func NewSectorClient(c config) *SectorClient {
	return &SectorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sector.Hooks(f(g(h())))`.
func (c *SectorClient) Use(hooks ...Hook) {
	c.hooks.Sector = append(c.hooks.Sector, hooks...)
}

// Create returns a create builder for Sector.
func (c *SectorClient) Create() *SectorCreate {
	mutation := newSectorMutation(c.config, OpCreate)
	return &SectorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Sector entities.
func (c *SectorClient) CreateBulk(builders ...*SectorCreate) *SectorCreateBulk {
	return &SectorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Sector.
func (c *SectorClient) Update() *SectorUpdate {
	mutation := newSectorMutation(c.config, OpUpdate)
	return &SectorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SectorClient) UpdateOne(s *Sector) *SectorUpdateOne {
	mutation := newSectorMutation(c.config, OpUpdateOne, withSector(s))
	return &SectorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SectorClient) UpdateOneID(id int) *SectorUpdateOne {
	mutation := newSectorMutation(c.config, OpUpdateOne, withSectorID(id))
	return &SectorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Sector.
func (c *SectorClient) Delete() *SectorDelete {
	mutation := newSectorMutation(c.config, OpDelete)
	return &SectorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SectorClient) DeleteOne(s *Sector) *SectorDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SectorClient) DeleteOneID(id int) *SectorDeleteOne {
	builder := c.Delete().Where(sector.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SectorDeleteOne{builder}
}

// Query returns a query builder for Sector.
func (c *SectorClient) Query() *SectorQuery {
	return &SectorQuery{
		config: c.config,
	}
}

// Get returns a Sector entity by its id.
func (c *SectorClient) Get(ctx context.Context, id int) (*Sector, error) {
	return c.Query().Where(sector.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SectorClient) GetX(ctx context.Context, id int) *Sector {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAdjacentTables queries the AdjacentTables edge of a Sector.
func (c *SectorClient) QueryAdjacentTables(s *Sector) *AdjacentTableQuery {
	query := &AdjacentTableQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sector.Table, sector.FieldID, id),
			sqlgraph.To(adjacenttable.Table, adjacenttable.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, sector.AdjacentTablesTable, sector.AdjacentTablesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SectorClient) Hooks() []Hook {
	return c.hooks.Sector
}

// SuperAdminClient is a client for the SuperAdmin schema.
type SuperAdminClient struct {
	config
}

// NewSuperAdminClient returns a client for the SuperAdmin from the given config.
func NewSuperAdminClient(c config) *SuperAdminClient {
	return &SuperAdminClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `superadmin.Hooks(f(g(h())))`.
func (c *SuperAdminClient) Use(hooks ...Hook) {
	c.hooks.SuperAdmin = append(c.hooks.SuperAdmin, hooks...)
}

// Create returns a create builder for SuperAdmin.
func (c *SuperAdminClient) Create() *SuperAdminCreate {
	mutation := newSuperAdminMutation(c.config, OpCreate)
	return &SuperAdminCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SuperAdmin entities.
func (c *SuperAdminClient) CreateBulk(builders ...*SuperAdminCreate) *SuperAdminCreateBulk {
	return &SuperAdminCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SuperAdmin.
func (c *SuperAdminClient) Update() *SuperAdminUpdate {
	mutation := newSuperAdminMutation(c.config, OpUpdate)
	return &SuperAdminUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SuperAdminClient) UpdateOne(sa *SuperAdmin) *SuperAdminUpdateOne {
	mutation := newSuperAdminMutation(c.config, OpUpdateOne, withSuperAdmin(sa))
	return &SuperAdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SuperAdminClient) UpdateOneID(id int) *SuperAdminUpdateOne {
	mutation := newSuperAdminMutation(c.config, OpUpdateOne, withSuperAdminID(id))
	return &SuperAdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SuperAdmin.
func (c *SuperAdminClient) Delete() *SuperAdminDelete {
	mutation := newSuperAdminMutation(c.config, OpDelete)
	return &SuperAdminDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SuperAdminClient) DeleteOne(sa *SuperAdmin) *SuperAdminDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SuperAdminClient) DeleteOneID(id int) *SuperAdminDeleteOne {
	builder := c.Delete().Where(superadmin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SuperAdminDeleteOne{builder}
}

// Query returns a query builder for SuperAdmin.
func (c *SuperAdminClient) Query() *SuperAdminQuery {
	return &SuperAdminQuery{
		config: c.config,
	}
}

// Get returns a SuperAdmin entity by its id.
func (c *SuperAdminClient) Get(ctx context.Context, id int) (*SuperAdmin, error) {
	return c.Query().Where(superadmin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SuperAdminClient) GetX(ctx context.Context, id int) *SuperAdmin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SuperAdminClient) Hooks() []Hook {
	return c.hooks.SuperAdmin
}
